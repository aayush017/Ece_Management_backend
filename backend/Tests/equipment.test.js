// Generated by CodiumAI
const express = require('express');
const {
  addEquipments,
  getEquipmentsByLab,
  updateEquipments,
  getAllEquipments,

  deleteEquipments,
} = require('../controllers/equipmentsController');
const router = express.Router();
const Equipment = require('../models/Equipment');


describe('addEquipments', () => {

    // Successfully add a new equipment with only name and quantity fields
    it('should add a new equipment with only name and quantity fields, but return 500 if lab is missing', async () => {
      const req = {
        body: {
          name: 'Equipment 2',
          quantity: 2
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      await addEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while adding the equipment' });
    });

    // Successfully add a new equipment with only name and description fields
    it('should add a new equipment with only name and description fields and return 500 on error', async () => {
      const req = {
        body: {
          name: 'Equipment 3',
          description: 'Description 3'
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      await addEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while adding the equipment' });
    });

    // Return a 500 status code and an error message when an error occurs while saving the equipment
    it('should return a 500 status code and an error message when an error occurs while saving the equipment', async () => {
      const req = {
        body: {
          name: 'Equipment 4',
          lab: 'Lab 4',
          description: 'Description 4',
          quantity: 4,
          allotmentDays: 7
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      const mockError = new Error('An error occurred while saving the equipment');
      const mockSave = jest.fn().mockRejectedValue(mockError);
      jest.spyOn(Equipment.prototype, 'save').mockImplementation(mockSave);
      await addEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while adding the equipment' });
      expect(mockSave).toHaveBeenCalled();
    });

    // Return a 500 status code and an error message when the request body is empty
    it('should return a 500 status code and an error message when the request body is empty', async () => {
      const req = {
        body: {}
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      await addEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while adding the equipment' });
    });

    // Return a 500 status code and an error message when the name field is missing
    it('should return a 500 status code and an error message when the name field is missing', async () => {
      const req = {
        body: {
          lab: 'Lab 6',
          description: 'Description 6',
          quantity: 6,
          allotmentDays: 7
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      await addEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while adding the equipment' });
    });
});

// Generated by CodiumAI

describe('getAllEquipments', () => {

    // Retrieve all equipment when there is data in the database
    it('should retrieve all equipment when there is data in the database', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      jest.setTimeout(20000); // Increase timeout to 20 seconds
      jest.spyOn(Equipment, 'find').mockResolvedValueOnce([{ name: 'Equipment 1' }, { name: 'Equipment 2' }]);
      await getAllEquipments(req, res);
      expect(res.json).toHaveBeenCalledWith(expect.any(Array));
      expect(res.json).toHaveBeenCalledWith([{ name: 'Equipment 1' }, { name: 'Equipment 2' }]);
    });

    // Return a JSON response with all equipment data
    it('should return a JSON response with all equipment data', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockResolvedValue(['equipment1', 'equipment2']);
      await getAllEquipments(req, res);
      expect(res.json).toHaveBeenCalledWith(['equipment1', 'equipment2']);
    }, 10000);

    // Handle successful requests without setting a status code
    it('should handle successful requests without setting a status code', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockResolvedValue([]);
      await getAllEquipments(req, res);
      expect(res.status).not.toHaveBeenCalled();
    });

    // Handle errors when retrieving equipment data
    it('should handle errors when retrieving equipment data', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockRejectedValueOnce(new Error('Database error'));
      await getAllEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while fetching all equipment' });
    });

    // Return a 500 status code for server errors
    it('should return a 500 status code for server errors', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockRejectedValueOnce(new Error('Database error'));
      await getAllEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
    });

    // Handle invalid requests with incorrect parameters
});

// Generated by CodiumAI

describe('getAllEquipments', () => {

    // Retrieve all equipment when there is data in the database
    it('should retrieve all equipment when there is data in the database', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      jest.setTimeout(20000); // Increase timeout to 20 seconds
      jest.spyOn(Equipment, 'find').mockResolvedValueOnce([{ name: 'Equipment 1' }, { name: 'Equipment 2' }]);
      await getAllEquipments(req, res);
      expect(res.json).toHaveBeenCalledWith(expect.any(Array));
      expect(res.json).toHaveBeenCalledWith([{ name: 'Equipment 1' }, { name: 'Equipment 2' }]);
    });

    // Return a JSON response with all equipment data
    it('should return a JSON response with all equipment data', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockResolvedValue(['equipment1', 'equipment2']);
      await getAllEquipments(req, res);
      expect(res.json).toHaveBeenCalledWith(['equipment1', 'equipment2']);
    }, 10000);

    // Handle successful requests without setting a status code
    it('should handle successful requests without setting a status code', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockResolvedValue([]);
      await getAllEquipments(req, res);
      expect(res.status).not.toHaveBeenCalled();
    });

    // Handle errors when retrieving equipment data

    // Return a 500 status code for server errors
    it('should return a 500 status code for server errors', async () => {
      const req = {};
      const res = {
        json: jest.fn(),
        status: jest.fn().mockReturnThis()
      };
      Equipment.find = jest.fn().mockRejectedValueOnce(new Error('Database error'));
      await getAllEquipments(req, res);
      expect(res.status).toHaveBeenCalledWith(500);
    });

    // Handle invalid requests with incorrect parameters
});

// Generated by CodiumAI

describe('updateEquipments', () => {

    // Successfully update an equipment with valid input data
    it('should successfully update an equipment with valid input data', async () => {
      const req = {
        params: { id: 'validId' },
        body: {
          name: 'Updated Equipment',
          lab: 'Updated Lab',
          description: 'Updated Description',
          quantity: 10,
          allotmentDays: 5
        }
      };
      const res = {
        json: jest.fn()
      };
      const updatedEquipment = {
        _id: 'validId',
        name: 'Updated Equipment',
        lab: 'Updated Lab',
        description: 'Updated Description',
        quantity: 10,
        allotmentDays: 5
      };
      Equipment.findByIdAndUpdate = jest.fn().mockResolvedValue(updatedEquipment);

      await updateEquipments(req, res);

      expect(Equipment.findByIdAndUpdate).toHaveBeenCalledWith(
        'validId',
        {
          name: 'Updated Equipment',
          lab: 'Updated Lab',
          description: 'Updated Description',
          quantity: 10,
          allotmentDays: 5
        },
        { new: true }
      );
      expect(res.json).toHaveBeenCalledWith({
        message: 'Equipment updated successfully',
        equipment: updatedEquipment
      });
    });

    // Return a JSON response with a success message and the updated equipment
    it('should return a JSON response with a success message and the updated equipment', async () => {
      const req = {
        params: { id: 'validId' },
        body: {
          name: 'Updated Equipment',
          lab: 'Updated Lab',
          description: 'Updated Description',
          quantity: 10,
          allotmentDays: 5
        }
      };
      const res = {
        json: jest.fn()
      };
      const updatedEquipment = {
        _id: 'validId',
        name: 'Updated Equipment',
        lab: 'Updated Lab',
        description: 'Updated Description',
        quantity: 10,
        allotmentDays: 5
      };
      Equipment.findByIdAndUpdate = jest.fn().mockResolvedValue(updatedEquipment);

      await updateEquipments(req, res);

      expect(res.json).toHaveBeenCalledWith({
        message: 'Equipment updated successfully',
        equipment: updatedEquipment
      });
    });

    // Update equipment with only required fields
    it('should update equipment with only required fields', async () => {
      const req = {
        params: { id: 'validId' },
        body: {
          name: 'Updated Equipment'
        }
      };
      const res = {
        json: jest.fn()
      };
      const updatedEquipment = {
        _id: 'validId',
        name: 'Updated Equipment',
        lab: '',
        description: '',
        quantity: 0,
        allotmentDays: 0
      };
      Equipment.findByIdAndUpdate = jest.fn().mockResolvedValue(updatedEquipment);

      await updateEquipments(req, res);

      expect(Equipment.findByIdAndUpdate).toHaveBeenCalledWith(
        'validId',
        {
          name: 'Updated Equipment'
        },
        { new: true }
      );
      expect(res.json).toHaveBeenCalledWith({
        message: 'Equipment updated successfully',
        equipment: updatedEquipment
      });
    });

    // Return a 500 error response when an error occurs during update
    it('should return a 500 error response when an error occurs during update', async () => {
      const req = {
        params: { id: 'validId' },
        body: {
          name: 'Updated Equipment',
          lab: 'Updated Lab',
          description: 'Updated Description',
          quantity: 10,
          allotmentDays: 5
        }
      };
      const res = {
        status: jest.fn().mockReturnThis(),
        json: jest.fn()
      };
      Equipment.findByIdAndUpdate = jest.fn().mockRejectedValue(new Error('Update error'));

      await updateEquipments(req, res);

      expect(Equipment.findByIdAndUpdate).toHaveBeenCalledWith(
        'validId',
        {
          name: 'Updated Equipment',
          lab: 'Updated Lab',
          description: 'Updated Description',
          quantity: 10,
          allotmentDays: 5
        },
        { new: true }
      );
      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while updating the equipment' });
    });
});


// Generated by CodiumAI

describe('deleteEquipments', () => {

    // Error message is returned when equipment ID is not provided
    it('should return error message when equipment ID is not provided', async () => {
      const req = { params: {} };
      const res = { status: jest.fn().mockReturnThis(), json: jest.fn() };

      // Mock the Equipment.findByIdAndRemove function to throw an error when called without parameters
      Equipment.findByIdAndRemove = jest.fn().mockImplementation(() => {
        throw new Error('Equipment ID not provided');
      });

      await deleteEquipments(req, res);

      expect(res.status).toHaveBeenCalledWith(500);
      expect(res.json).toHaveBeenCalledWith({ error: 'An error occurred while deleting the equipment' });
    });
});
